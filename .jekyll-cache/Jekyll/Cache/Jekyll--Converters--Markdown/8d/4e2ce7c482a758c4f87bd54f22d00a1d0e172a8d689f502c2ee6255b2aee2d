I"m<h2 id="문제">문제</h2>

<p>안녕하세요.<br />
 백준에서 삼성 SW 역량 테스트 기출 문제집에 게시된 <a href="https://www.acmicpc.net/problem/16236">16236번 아기 상어</a> 문제 풀이를 소개하겠습니다.</p>

<p>이 문제는 아기 상어가 N x N 크기의 공간에서 자신보다 작은 물고기를 잡아 먹으면서 성장을 하는 문제 입니다.</p>

<p><img src="/assets/images/posts/2021-10-03-BJ-16236/example.PNG" alt="example" /></p>
<center><em> 상어의 이동 예시, 총 이동 시간은 14 </em></center>
<p><br /></p>

<p>상어가 최단거리의 물고기의 위치를 탐색하는 것이 이 문제의 포인트 입니다. 물고기 위치를 탐색하기 위해 DFS가 아닌 BFS를 활용해야 합니다. DFS보다 BFS의 난이도가 좀 더 높은 편입니다. 그 이유는 한 방향의 길을 계속 이어서 탐색하는 것이 아니고, 매번 다른 방향에서의 이동 거리와 조건을 체크해줘야 하기 때문입니다. 자세한 내용은 아래에서 확인하도록 하겠습니다.</p>

<h3 id="주어진-정보">주어진 정보</h3>
<ul>
  <li>상어의 처음 크기는 2</li>
  <li>자신의 크기 만큼의 물고기를 먹으면 상어의 크기는 +1</li>
  <li>물고기의 크기는 최대 6</li>
  <li>한 칸을 이동할 때 마다 1초가 지나고, 물고기를 잡아 먹는 시간은 0초</li>
  <li>상어는 자신보다 작은 물고기만 먹을 수 있고, 같은 크기의 물고기는 지나가는 것만 가능</li>
  <li>더 이상 먹을 수 있는 물고기가 없으면 종료</li>
</ul>

<h3 id="해결-방향">해결 방향</h3>

<p>먼저 문제에서 요구하는 출력은 상어의 이동 시간(이동 거리)이기 때문에, BFS를 진행 할 때 마다 이동 거리를 return 하도록 합니다. 이렇게 물고기를 먹을 때 마다 BFS 를 진행하고, 물고기를 더 이상 먹을 수 없다면 지금 까지 이동한 시간을 출력하면 됩니다.</p>

<p>BFS의 순서는 다음과 같습니다.</p>

<ol>
  <li>먹을 수 있는 물고기가 없으면 종료. (남은 물고기의 수가 0)</li>
  <li>현재 상어 위치를 비어있는 큐에 넣음</li>
  <li>BFS 탐색
    <ol>
      <li>큐가 비어 있으면 탐색 종료</li>
      <li>큐에서 맨 앞을 꺼내서 먹을 수 있는 물고기면
        <ol>
          <li>최단 거리 체크</li>
          <li>위치 우선 순위 체크 (제일 위, 제일 왼쪽 우선 순위)</li>
          <li>먹은 물고기 위치 갱신 후, 다시 큐에서 꺼내는 단계로 이동</li>
        </ol>
      </li>
      <li>현재 위치에서 +1 칸 이동 시도 ( 동,서,남,북 네 방향 )
        <ol>
          <li>영역 바깥, 중복 방문, 물고기 크기 체크</li>
          <li>이동 가능한 칸을 큐의 맨 뒤에 삽입</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>최단 거리의 물고기를 먹고 상어의 위치 갱신</li>
</ol>

<p>전체 코드와 주석이 위의 내용처럼 아래에 작성되어 있습니다.</p>

<h2 id="풀이">풀이</h2>
<h3 id="풀이-코드">풀이 코드</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>										<span class="c1">// 공간 크기</span>
<span class="kt">int</span> <span class="n">sz_shark</span><span class="p">,</span> <span class="n">cnt_fish</span><span class="p">,</span> <span class="n">cnt_eat</span><span class="p">;</span>			<span class="c1">// 상어 크기, 총 물고기 수, 먹은 수</span>
<span class="kt">int</span> <span class="n">dd</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="p">};</span>	<span class="c1">// 방향 우선순위 불가능</span>

<span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>		<span class="c1">// 공간</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos_shark</span><span class="p">;</span>		<span class="c1">// 상어가 있는 좌표</span>

<span class="c1">// 상어가 이동 가능한 영역인지 체크</span>
<span class="kt">bool</span> <span class="nf">check_way</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 상어가 물고기를 먹고 위치, 크기 갱신</span>
<span class="kt">void</span> <span class="nf">eat_fish</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">fish</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">arr</span><span class="p">[</span><span class="n">fish</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">fish</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">arr</span><span class="p">[</span><span class="n">pos_shark</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos_shark</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pos_shark</span> <span class="o">=</span> <span class="n">fish</span><span class="p">;</span>

	<span class="n">cnt_fish</span><span class="o">--</span><span class="p">;</span>
	<span class="n">cnt_eat</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt_eat</span> <span class="o">==</span> <span class="n">sz_shark</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnt_eat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sz_shark</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// BFS를 이용해 다음에 먹을 물고기를 찾아 이동 거리를 리턴</span>
<span class="kt">int</span> <span class="nf">find_target</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">arr_visited</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>	<span class="c1">// BFS 탐색을 위한 방문 지도, 각 칸에는 해당 좌표까지의 이동 거리 값 계산 </span>
	<span class="n">vector</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>	<span class="c1">// BFS 탐색을 위한 큐</span>
	
	<span class="n">Q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pos_shark</span><span class="p">);</span>		<span class="c1">// 큐에 처음 시작 위치를 상어 위치로 넣음</span>
	<span class="n">arr_visited</span><span class="p">[</span><span class="n">pos_shark</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos_shark</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// 처음 시작 위치는 이동거리 0</span>

	<span class="kt">int</span> <span class="n">dist_min</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r_min</span><span class="p">,</span> <span class="n">c_min</span><span class="p">;</span>
	<span class="n">r_min</span> <span class="o">=</span> <span class="n">c_min</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
	<span class="c1">// 탐색 초기화 끝</span>


	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 큐가 비어 있으면 종료</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="c1">// 맨 앞에서 다음 탐색 위치 꺼냄</span>
		<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">Q</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Q</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>


		<span class="c1">// 다음 이동하는 위치가 상어보다 작은 물고기가 있는 위치인 경우, (물고기의 크기는 6보다 크지 않음)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sz_shark</span> <span class="o">&amp;&amp;</span> 
			<span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">9</span> <span class="o">&amp;&amp;</span>
			<span class="n">arr_visited</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dist_min</span><span class="p">)</span> <span class="p">{</span>
			
			<span class="c1">// 더 짧은 거리의 먹을 수 있는 물고기가 있다면, 최소 이동 거리 갱신, 아마 BFS 특성상 자동으로 만족?</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr_visited</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist_min</span><span class="p">)</span> 
				<span class="n">dist_min</span> <span class="o">=</span> <span class="n">arr_visited</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">];</span>

			<span class="c1">// 우선순위에 따른 물고기 위치 선택</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;=</span> <span class="n">r_min</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">r_min</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">c_min</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">c_min</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// 현재 위치에서 네 방향으로 이동 가능한 위치 탐색</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">way</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">way</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">way</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">r_</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">dd</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">way</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">c_</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="o">+</span> <span class="n">dd</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">way</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">dist_next</span> <span class="o">=</span> <span class="n">arr_visited</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// 다음 이동 거리는 현재에서 +1 만큼</span>


			<span class="k">if</span> <span class="p">(</span><span class="n">check_way</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span> <span class="n">c_</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>  <span class="k">continue</span><span class="p">;</span>	<span class="c1">// 공간 바깥 체크</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr_visited</span><span class="p">[</span><span class="n">r_</span><span class="p">][</span><span class="n">c_</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">arr_visited</span><span class="p">[</span><span class="n">r_</span><span class="p">][</span><span class="n">c_</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dist_next</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>	<span class="c1">// 중복 방문 체크</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">r_</span><span class="p">][</span><span class="n">c_</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sz_shark</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>		<span class="c1">// 상어보다 큰 물고기 체크</span>

			<span class="c1">// 이동 조건에 만족하면 큐에 삽입</span>
			<span class="n">Q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span> <span class="n">c_</span><span class="p">));</span>
			<span class="n">arr_visited</span><span class="p">[</span><span class="n">r_</span><span class="p">][</span><span class="n">c_</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 한번도 이동을 못했다면 이동거리는 0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dist_min</span> <span class="o">==</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> 
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">eat_fish</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r_min</span><span class="p">,</span> <span class="n">c_min</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">dist_min</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">()</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// 물고기를 먹을 수 없을 때 까지 반복</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt_fish</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">find_target</span><span class="p">();</span>	<span class="c1">// BFS를 이용해 먹이를 찾고 이동 거리를 리턴</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="k">break</span><span class="p">;</span>		<span class="c1">// 이동 하지 못하면 종료</span>
		<span class="n">t</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">;</span>					<span class="c1">// 이동 거리만큼 시간을 늘림</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span> 

	<span class="n">arr</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">cnt_eat</span> <span class="o">=</span> <span class="n">cnt_fish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sz_shark</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">)</span>	<span class="n">cnt_fish</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="n">pos_shark</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">solution</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="다른-테스트-케이스">다른 테스트 케이스</h3>

<p>혹시 예제 케이스는 통과 했는데, 답안 코드 제출시 틀린다면 아래의 케이스들을 테스트 해보길 바랍니다.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
10
0 1 4 6 1 4 5 4 0 3
2 0 0 9 0 0 6 0 0 0
4 3 2 4 6 3 0 2 1 6
0 0 0 0 1 0 0 1 0 6
0 0 0 6 0 4 1 4 0 1
0 3 0 1 6 0 3 1 0 4
6 5 0 2 0 0 5 1 0 1
0 4 0 4 1 1 2 5 6 6
1 0 5 6 5 1 0 1 2 0
5 6 3 0 6 0 1 1 6 0
answer:103

10
5 6 3 0 5 5 4 4 3 0
2 4 0 4 0 1 0 1 0 6
0 3 4 1 0 0 3 1 1 0
0 5 1 0 1 6 1 3 5 1
0 3 0 1 1 0 4 0 1 0
0 5 1 5 6 0 3 4 0 9
0 5 5 3 0 0 4 5 0 3
2 5 0 3 3 2 0 0 3 2
2 6 5 0 0 4 1 1 6 3
1 3 1 3 0 1 0 0 0 5
answer:105

10
5 3 2 0 0 1 2 0 4 0
3 0 3 1 0 0 3 0 6 1
0 3 0 5 0 5 4 4 2 5
3 0 0 3 0 6 1 5 4 2
1 0 2 0 2 0 3 0 0 6
1 1 1 1 1 1 1 1 0 0
2 0 2 1 9 6 0 0 4 3
1 6 1 0 6 0 5 0 1 0
6 5 4 0 1 2 1 3 5 0
0 1 6 6 1 4 3 0 1 1
answer:102

10
2 0 2 0 1 1 1 0 1 0
0 4 4 0 4 0 0 0 3 0
4 3 5 0 1 0 2 6 0 0
0 0 5 5 3 1 3 1 3 4
6 0 5 1 4 2 4 0 5 0
0 0 5 0 2 1 1 2 1 0
2 0 5 2 4 0 9 1 6 2
4 1 2 0 3 0 3 2 4 6
3 0 1 0 4 0 0 5 0 1
0 4 1 1 6 6 1 6 0 0
answer:87

</span></code></pre></div></div>

<h3 id="해설">해설</h3>

<ul>
  <li>solution() : 먹을 수 있는 물고기 수 만큼 while loop를 수행</li>
  <li>find_target() : BFS 를 수행하는 함수, 이동 거리를 리턴</li>
  <li>eat_fish() : 먹을 수 있는 물고기가 있을 때, 상어의 위치를 바꾸고 먹은 횟수와 남은 물고기 수를 갱신
 <br /></li>
</ul>

<h3 id="앗-이걸-생각-못했네">앗 이걸 생각 못했네?</h3>

<ul>
  <li>문제에는 명시되어 있지 않지만, <ins>상어 크기 성장 시 먹은 횟수는 0으로 초기화 해야 합니다.</ins></li>
  <li>물고기는 최대 크기가 6이기 때문에 상어는 7까지만 커져도 됩니다.
    <ul>
      <li>상어가 8 이상으로 커지는 경우, 초기 큐에서 상어의 위치를 꺼내다가 빈곳이 아니므로 물고기를 먹은것으로 잘못 처리 할 수 있습니다.</li>
      <li>제 풀이에는 상어의 크기에 대한 제한이 없기 때문에 물고기를 먹는 조건에 9는 못먹게 해놓았습니다.</li>
    </ul>
  </li>
  <li>체크해야할 조건들이 많기 때문에 조건 처리 실수를 조심해야 합니다.
    <ul>
      <li>중복 방문 체크시, 현재 이동 거리와 같거나 작으면 가지 않는다. 이동 거리가 같은데 다시 큐에 넣는 것은 계산 및 시간 낭비를 유발 합니다.</li>
      <li>방향 우선 순위 비교를 위한 비교연산자 체크 (이상/초과, 이하/미만)</li>
    </ul>
  </li>
</ul>

<h2 id="다른-풀이">다른 풀이</h2>
<p><a href="https://github.com/TJ-kor/Solutions/blob/main/Baekjoon/16235_tree_coin.cpp">16235번 나무재테크 1차 풀이</a></p>

<p><a href="https://github.com/TJ-kor/Solutions">기타 다른 문제 풀이 코드 (github)</a></p>
:ET